% Copyright (C) 2008 Bert Burgemeister
%
% Permission is granted to copy, distribute and/or modify this
% document under the terms of the GNU Free Documentation License,
% Version 1.2 or any later version published by the Free Software
% Foundation; with no Invariant Sections, no Front-Cover Texts and
% no Back-Cover Texts. For details see file COPYING.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Control Structure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Predicates}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{LIST}{1cm}

  \IT{(\FU*{EQ} \VAR{foo bar})} 
  \retval{\T} if \VAR{foo} and \VAR{bar} are identical.

  \IT{(\FU*{EQL} \VAR{foo bar})} 
  \retval{\T} if \VAR{foo} and \VAR{bar}
  are identical, or are the same character, or are the same number.

  \IT{(\FU*{EQUAL} \VAR{foo bar})} 
  \retval{\T} if \VAR{foo} and \VAR{bar}
  are \FU{EQL}, or are conses with \FU{equal} cars and cdrs, or are
  strings or bit-vectors with  \FU{eql} elements, or are equivalent pathnames.

  \IT{(\FU*{EQUALP} \VAR{foo bar})} 
  \retval{\T} if \VAR{foo} and \VAR{bar}
  are \FU{EQUAL}, or if they have corresponding components of the same
  type which are \kwd{equalp}.

  \IT{(\FU*{CONSTANTP} \VAR{foo} \Op{\VAR{environment}})} 
  \retval{\T} if \VAR{foo} is a constant form.

  \IT{(\FU*{NOT} \VAR{bool})}
  Return \retval{\NIL} if \VAR{bool} is \T, return \retval{\T} if \VAR{bool} is \NIL.

  \IT{(\FU*{FUNCTIONP} \VAR{foo})}
  \retval{\T} if \VAR{foo} is of type \kwd{function}.

  \IT{(\FU*{FBOUNDP} \VAR{foo})}
  \retval{\T} if \VAR{foo} is the name of a global function or macro..


\end{LIST}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Variables}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{LIST}{1cm}

  \IT{(\kwd*{DEFVAR} \VAR{name} \OP{\VAR{value}
      \Op{\VAR{documentation}}})} 
  Unless bound already, assign \VAR{value} to dynamic variable
  \retval{\VAR{name}}. 

  \IT{(\kwd*{DEFPARAMETER} \VAR{name} \VAR{value}
    \Op{\VAR{documentation}})} 
  Assign \VAR{value} to dynamic variable \retval{\VAR{name}}.

  \IT{(\kwd*{DEFCONSTANT} \VAR{name} \VAR{value}
    \Op{\VAR{documentation}})} 
  Assign \VAR{value} to global constant \retval{\VAR{name}}.

  \IT{(\FU*{NTH-VALUE} \VAR{n} \VAR{form})} 
  \retval{\VAR{n}th return value} of \VAR{form}.

  \IT{(\xorGOO{\SF*{SETF}\\\SF*{PSETF}}{\}} \Goos{\VAR{place}
      \VAR{value}})} 
  Set \VAR{place}s to \retval{\VAR{value}s}, resp. Work sequentially/in
  parallel, resp. 

  \IT{(\xorGOO{\SF*{SETQ}\\\SF*{PSETQ}}{\}} \Goos{\VAR{symbol}
      \VAR{value}})} 
  Set \VAR{symbol}s to \retval{\VAR{value}s}, resp. Work sequentially/in
  parallel, resp. 

  \IT{(\FU*{SET} \VAR{symbol} \VAR{foo})}  
  Set \VAR{symbol}'s value cell to \retval{\VAR{foo}}.

  \IT{(\SF*{MULTIPLE-VALUE-SETQ} \VAR{vars} \VAR{form})}
  Set \VAR{vars} to the respective values returned by
  \VAR{form}. Return \retval{\VAR{form}'s primary value}.

  \IT{(\SF*{SHIFTF} \RP{\VAR{place}} \VAR{foo})} Store \VAR{foo} in
  rightmost \VAR{place} shifting values of \VAR{place}s left, returning
  \retval{first \VAR{place}}.

  \IT{(\SF*{ROTATEF} \OPn{\VAR{place}})} Rotate values of \VAR{place}s left,
  old first becoming new last \VAR{place}. Return \retval{\NIL}.

  \IT{(\FU*{MAKUNBOUND} \VAR{symbol})}
  Make \retval{\VAR{symbol}} unbound.

  \label{:property_lists}
  \IT{\arrGOO{(\FU*{GET} \VAR{ symbol} \VAR{ key }
      \OP{\VAR{default}\DF{\NIL}})\\ 
      (\FU*{GETF} \VAR{ place} \VAR{ key }
      \OP{\VAR{default}\DF{\NIL}})}{\}}} 
  \retval{First entry \VAR{key}} from property list stored in
  \VAR{symbol}/in \VAR{place}, resp., or \retval{\VAR{default}} if
  there was no \VAR{key}. \kwd{setf}able.

  \IT{(\FU*{GET-PROPERTIES} \VAR{plist} \VAR{key-list})}
  Return \retval{Key} and \retvalii{value} of first entry from \VAR{plist}
  matching a key from \VAR{key-list}, and \retvaliii{tail of
    \VAR{plist}} starting with \VAR{key}. Return \retval{\NIL},
  \retvalii{\NIL}, and  \retvaliii{\NIL} if there was no \VAR{key}.

  \IT{\arrGOO{(\FU*{REMPROP} \VAR{ symbol} \VAR{ key})\\
      (\SF*{REMF} \VAR{ place} \VAR{ key})}{\}}}
  Remove fist entry \VAR{key} from property list stored in
  \VAR{symbol}/in \VAR{place}, resp. Return \retval{\T} if \VAR{key}
  was there, or \retval{\NIL} otherwise.

\end{LIST}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Functions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{section:Functions}


Below, lambda list \OPn{\VAR{fu-arg}} has the form 
(\OPn{\VAR{var}}
\OP{\kwd*{\&optional} \Goos{\VAR{var}\XOR(\VAR{var} \OP{\VAR{init}
      \Op{\VAR{supplied-p}}})}}
\Op{\kwd*{\&rest} \VAR{var}}
\OP{\kwd*{\&key} \GOos{\VAR{var}\XOR(\Goo{\VAR{var}\XOR(\kwd{:}\VAR{key}
      \VAR{var})}
    \OP{\VAR{init}\Op{\VAR{supplied-p}}})}
  \Op{\kwd*{\&allow-other-keys}}}
\OP{\kwd*{\&aux}\Goos{\VAR{var}\XOR(\VAR{var} \Op{\VAR{init}})}}
). \VAR{supplied-p} is \T\ if there is a corresponding argument.

\begin{LIST}{1cm}

  \IT{(\xorGOO{\SF*{DEFUN} \VAR{ foo}\\ \SF*{LAMBDA}}{\}}
    (\VAR{\OPn{fu-arg}}) \OPn{(\kwd{declare} \OPn{\VAR{decl}})}
    \Op{\VAR{documentation}} 
    \OPn{\VAR{form}})} 
  Define function with \retval{name \VAR{foo}} or an anonymous
  function, resp., which
  applies \VAR{form}s to \VAR{fu-arg}s.

  \IT{(\xorGOO{\SF*{FLET}\\ \SF*{LABELS}}{\}}%
    (\OPn{(\VAR{name}
      (\OPn{\VAR{fu-arg}}) 
      \OPn{(\kwd{declare} \OPn{\VAR{local-decl}})}%
      \Op{\VAR{documentation}}
      \OPn{\VAR{local-form}})})\OPn{(\kwd{declare} \VAR{decl})}
    \OPn{\VAR{form}})} 
  Evaluate \VAR{form}s with
  locally defined functions \OPn{\VAR{name}}. Only for \SF{LABELS},
  \VAR{name}s are visible inside \VAR{local-forms}. Return
  \retval{values of \VAR{form}s}.

  \IT{(\SF*{FUNCTION} \VAR{foo})} Return \retval{function named \VAR{foo}}.

  \IT{(\FU*{APPLY} \VAR{function} \RP{\VAR{arg}})}
  Return \retval{value of \VAR{function}} called with
  \VAR{arg}s. Last \VAR{arg} must be a list.

  \IT{(\FU*{FUNCALL} \VAR{function} \OPn{arg})} 
  Return \retval{value of \VAR{function}} called with \VAR{arg}s.

  \IT{(\SF*{MULTIPLE-VALUE-CALL} \VAR{foo} \OPn{\VAR{form}})} Call function
  \VAR{foo} with values of \VAR{form}s as its arguments.  Return
  \retval{values returned by \VAR{foo}}.

  \IT{(\FU*{VALUES-LIST} \VAR{list})} 
  Return \retval{elements of \VAR{list}}.

  \IT{(\FU*{VALUES} \OPn{\VAR{foo}})} 
  Return \retval{\VAR{foo}s} as multiple values. \kwd{setf}able.

  \IT{(\FU*{MULTIPLE-VALUE-LIST} \OPn{\VAR{form}})} 
  Return \retval{values of \VAR{form}s}.

  \IT{(\FU*{COMPLEMENT} \VAR{function})}
  Return \retval{new function} with same arguments and same side effects
  as \VAR{function}, but with complementary truth value.

  \IT{(\FU*{CONSTANTLY} \VAR{foo})} 
  Return \retval{function} returning \VAR{foo}.

  \IT{(\FU*{IDENTITY} \VAR{foo})} 
  Return \retval{\VAR{foo}}.

  \IT{(\FU*{FUNCTION-LAMBDA-EXPRESSION} \VAR{function})}
  If available, return \retval{Lambda expression} of \VAR{function},
  \retvalii{\NIL} if \VAR{function} was 
  defined in null environment, and \retvaliii{name} of \VAR{function}.

  \IT{(\FU*{FDEFINITION} \VAR{foo})} 
  \retval{Definition} of function \VAR{foo}. \kwd{setf}able.

  \IT{(\FU*{FMAKUNBOUND} \VAR{name})}
  Remove global function or macro definition \retval{\VAR{name}}.

  \IT{\arrGOO{\CNS*{CALL-ARGUMENTS-LIMIT}\\
      \CNS*{LAMBDA-PARAMETERS-LIMIT}}{\}}}
  Upper bound of the number of function arguments or lambda list
  parameters, resp.; $>=50$. 

  \IT{\CNS*{MULTIPLE-VALUES-LIMIT}}
  Upper bound of the number of values a function can return; $>20$.

\end{LIST}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Below, macro lambda list \OPn{\VAR{macro-arg}} has the form of either
(\Op{\kwd*{\&whole} \VAR{var}}%
\Op{\kwd*{\&environment} \VAR{var}}
\OPn{\VAR{var}}
\Op{\kwd*{\&environment} \VAR{var}}
\Op{\kwd*{\&optional}\Goos{\VAR{var}\XOR(\VAR{var} \Op{\VAR{init}
      \Op{\VAR{supplied-p}}})}}
\Op{\kwd*{\&environment} \VAR{var}}
\Op{\Goo{\kwd*{\&rest}\XOR\kwd*{\&body}} \VAR{var}}
\Op{\kwd*{\&environment} \VAR{var}}
\OP{\kwd*{\&key}\GOos{\VAR{var}\XOR(\Goo{\VAR{var}\XOR(\kwd{:}\VAR{key}
      \VAR{var})}%
    \OP{\VAR{init}\Op{\VAR{supplied-p}}})}%
  \Op{\kwd*{\&environment} \VAR{var}}
  \Op{\kwd*{\&allow-other-keys}}}
\Op{\kwd*{\&aux}\Goos{\VAR{var}\XOR(\VAR{var} \Op{\VAR{init}})}}%
\Op{\kwd*{\&environment} \VAR{var}}
)
or\\
(\Op{\kwd*{\&whole} \VAR{var}}%
\Op{\kwd*{\&environment} \VAR{var}}
\OPn{\VAR{var}}
\Op{\kwd*{\&environment} \VAR{var}}
\Op{\kwd*{\&optional}\Goos{\VAR{var}\XOR(\VAR{var} \Op{\VAR{init}
      \Op{\VAR{supplied-p}}})}}
\Op{\kwd*{\&environment} \VAR{var}}
. \VAR{var}). 
\kwd*{\&environment} \VAR{var} may appear only once.
\VAR{supplied-p} is \T\ if there is a corresponding argument.


\begin{LIST}{1cm}

  \IT{(\xorGOO{\SF*{DEFMACRO}\\\FU*{DEFINE-COMPILER-MACRO}}{\}}
    \VAR{name} \OPn{\VAR{macro-arg}}
    \OPn{(\kwd{declare} \OPn{\VAR{decl}})} \Op{\VAR{documentation}}
    \OPn{\VAR{form}})}
  Define macro \retval{\VAR{name}}.

  \IT{(\SF*{MACROLET} (\OPn{(\OPn{name} \OPn{\VAR{macro-arg}}
      \OPn{(\kwd{declare} \OPn{\VAR{local-decl}})} 
      \Op{\VAR{documentation}} \OPn{form})}) \OPn{(\kwd{declare}
      \OPn{\VAR{decl}})} \OPn{\VAR{body}})}  
  Evaluate \retval{\OPn{\VAR{body}}} with \VAR{name}s locally defined
  as corresponding macros which are invisible to each other.  

  \IT{(\SF*{SYMBOL-MACROLET} (\OPn{(\VAR{name}
      \OPn{\VAR{form}})})\OPn{(\kwd{declare} \OPn{\VAR{decl}})}
    \OPn{body})} 
  Evaluate \retval{\OPn{\VAR{body}}} with \VAR{name}s locally defined as
  corresponding symbol-macros. 

  \IT{(\SF*{DEFSETF} \VAR{function}\xorGOO{\VAR{update} \Op{\VAR{documentation}}\\
    \OPn{\VAR{arg} (\OPn{\VAR{var}}) \OPn{(\kwd{declare} \OPn{\VAR{
            decl}})} \Op{\VAR{documentation}}}}{\}})} 
  Specify how to \kwd{setf} a place accessed by
  \retval{\VAR{function}} if \VAR{function} evaluates all its
  arguments. 
  
  \IT{(\SF*{DEFINE-SETF-EXPANDER} \VAR{function} \OPn{\VAR{macro-arg}}
    \OPn{(\kwd{declare} \OPn{\VAR{decl}})} \Op{\VAR{documentation}}
    \OPn{\VAR{form}})}
  Specify how to \kwd{setf} a place accessed by \retval{\VAR{function}}.

  \IT{(\SF*{DEFINE-MODIFY-MACRO} \VAR{name} (\kwd{\&optional}
    \OPn{\VAR{var}} \kwd{\&rest} \OPn{\VAR{var}}) \VAR{function}
    \Op{documentation})} 
  Define macro \retval{\VAR{name}} able to read and write a place. On
  invokation, after applying \VAR{function} to place its return value
  is stored there.

  \IT{(\FU*{GET-SETF-EXPANSION} \VAR{place} \Op{\VAR{environment}})} 
  Return five values describing how to \kwd{setf} place.

  \IT{\CNS*{LAMBDA-LIST-KEYWORDS}} List of macro lambda list keywords.

\end{LIST}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Control Flow}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{LIST}{1cm}

  \IT{(\SF*{IF} \VAR{test} \VAR{then} \Op{\VAR{else}})} Evaluate and return
  \retval{\VAR{then}} if \VAR{test} returns \T, evaluate and return
  \retval{\VAR{else}} otherwise.

  \IT{(\SF*{COND} \OPn{(\VAR{test} \OPn{\VAR{then}})})} 
  Evaluate and return the
  \retval{\VAR{then}s} whose \VAR{test} returns \T, return
  \retval{\NIL} if all \VAR{test}s return \NIL.

  \IT{(\xorGOO{\SF*{WHEN}\\\SF*{UNLESS}}{\}} \VAR{test} \OPn{\VAR{foo}})}
  Evaluate \VAR{foo}s and return \retval{value of last \VAR{foo}} if
  \VAR{test} returns \T\ or \NIL, resp. Return \retval{\NIL} otherwise.

  \IT{(\SF*{CASE} \VAR{object} \GOOs{(\GOop{\VAR{key}}\Goos{\VAR{foo}})}
    \Op{(\Goo{\LIT{t}\XOR\kwd*{OTHERWISE}}\Goos{\VAR{foo}})})}
  Evaluate first \VAR{foo}s whose unevaluated \VAR{key} is either \kwd{eql} evaluated
  \VAR{object} or \LIT{t} or \LIT{otherwise}. Return \retval{value of
    last evaluated \VAR{foo}}.

  \IT{(\Goo{\SF*{CCASE}\XOR\SF*{ECASE}} \VAR{object} \Goos{(\GOop{\VAR{key}}\Goos{\VAR{foo}})})}
  Evaluate first \VAR{foo}s whose unevaluated \VAR{key} is \kwd{eql} evaluated
  \VAR{object}. Return \retval{value of last evaluated
    \VAR{foo}}. Signal correctible error/non-correctible error,
  resp., if no \VAR{key} matches and return \retval{\NIL} then.

  \IT{(\SF*{AND} \OPn{\VAR{form}})} Evaluate \VAR{form}s from left to
  right. Immediately return \retval{\NIL} if one \VAR{form}'s value is \NIL. Return
  \retval{value of last \VAR{form}} otherwise. Without any \VAR{form}
  return \retval{\NIL}

  \IT{(\SF*{OR} \OPn{\VAR{form}})} Evaluate \VAR{form}s from left to
  right. Immediately return \retval{value of first non-\NIL-evaluating
    form}. Return \retval{\NIL} if no \VAR{form} returns true.
  Return \retval{value of last \VAR{form}} otherwise.

  \IT{(\kwd*{PROGN} \OPn{\VAR{form}})} Sequence \VAR{form}s. Return
  \retval{value of last \VAR{form}}.

  \IT{(\xorGOO{\SF*{PROG}\\
      \SF*{PROG*}}{\}}
    (\orGOO{%
      \VAR{var}\\
      (\VAR{var } \Op{ \VAR{value}})}{\}^{\!\!*}})
    \OPn{(\kwd{declare} \OPn{\VAR{decl}})} 
    \xorGOO{\VAR{tag}\\\VAR{form}}{\}^{\!\!*}})}
  Evaluate \kwd{TAGBODY}-like body with locally bound
  \VAR{var}s. Return \retval{\NIL} or explicitly \retval{\kwd{return}ed value}.
  
  \IT{\arrGOO{%
      (\SF*{MULTIPLE-VALUE-PROG1} \VAR{ form-r} \OPn{\VAR{ form}})\\
      (\SF*{PROG1} \VAR{ form-r} \OPn{\VAR{ form}})\\
      (\SF*{PROG2} \VAR{ form-a} \VAR{ form-r} \OPn{\VAR{ form}})}{\}}}
  Evaluate all forms in order. Return \retval{values/1st value of \VAR{form-r}}.

  \IT{(\SF*{PROGV} \VAR{symbols} \VAR{values} \OPn{form})}
  Evaluate \VAR{form}s with \VAR{symbols} dynamically bound to \VAR{values} or
  \NIL. Return \retval{values returned by \VAR{form}s}.

  \IT{(\SF*{DESTRUCTURING-BIND} \VAR{foo} \VAR{bar}  \OPn{(\kwd{declare}
      \OPn{\VAR{decl}})} \OPn{\VAR{form}})} Evaluate \VAR{form}s, and return
  \retval{value of last \VAR{form}}, with
  variables from tree \VAR{foo} bound to corresponding elements of tree \VAR{bar}.

  \IT{(\kwd*{MULTIPLE-VALUE-BIND} (\OPn{\VAR{var}}) \VAR{values-form}
    \OPn{(\kwd{declare} \OPn{\VAR{decl}})} \OPn{\VAR{body-form}})} Evaluate
  body with \VAR{var}s bound to the return values of
  \VAR{values-form}. Return \retval{values returned by \VAR{body-form}s}.

  \IT{(\xorGOO{\SF*{LET}\\ 
      \SF*{LET*}}{\}}(%
    \orGOO{\VAR{name}\\
      (\VAR{name}\Op{\VAR{value}})}{\}^{\!\!*}}) 
    \OPn{(\kwd{declare} \OPn{\VAR{decl}})} 
    \OPn{\VAR{body}})}
  Evaluate \OPn{\VAR{body}} with \VAR{name}s bound to \VAR{value}s or
  \NIL. Return \retval{values returned by \OPn{\VAR{body}}}. In \SF{LET*},
  \VAR{value}s can refer to previous \VAR{name}s.

  \IT{(\SF*{LOCALLY} \OPn{(\kwd{declare} \OPn{\VAR{decl}})}
    \OPn{\VAR{body}})}
  Evaluate \OPn{\VAR{body}} with declarations \VAR{decl} in
  effect. Return \retval{values returned by \OPn{\VAR{body}}}. 

  \IT{(\SF*{RETURN-FROM} \VAR{foo} \Op{result})} Have nearest enclosing
  \kwd{block} \VAR{foo} return with \VAR{result}.

  \IT{(\SF*{RETURN} \Op{result})} 
  Have enclosing block return with \retval{\VAR{result}}.

  \IT{(\SF*{BLOCK} \VAR{name} \OPn{\VAR{form}})} Evaluate \VAR{form}s returning
  \retval{value of last \VAR{form}} unless interrupted by \SF{RETURN-FROM}.

  \IT{(\SF*{TAGBODY} \Goos{\VAR{tag}\XOR\VAR{form}})} 
  Evaluate \VAR{form}s. \VAR{tag}s (symbols or integers) are targets
  for \SF{GO}. Return \retval{\NIL}. 

  \IT{(\SF*{GO} \VAR{tag})} Jump within a \SF{tagbody} to nearest
  lexically enclosing \kwd{eql} \VAR{tag}.

  \IT{(\SF*{CATCH} \VAR{tag} \OPn{\VAR{form}})}  Evaluate \VAR{form}s returning
  \retval{value of last \VAR{form}} unless interrupted by \SF{THROW}.

  \IT{(\SF*{THROW} \VAR{tag form})} Have the nearest dynamically
  enclosing \SF{CATCH} with a tag \kwd{eq} \VAR{tag} return with the
  value of \VAR{form}.

  \IT{(\FU*{BREAK} \VAR{control} \OPn{args})}
  Jump into debugger, return \retval{\NIL}.
  See p.\ \pageref{section:Format}, \kwd{format}, for \VAR{control}
  and \VAR{args}. 

  \IT{(\FU*{SLEEP} \VAR{n})} Wait \VAR{n} seconds, return \retval{\NIL}.

\end{LIST}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Iteration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{LIST}{1cm}
  
  \IT{(\xorGOO{\SF*{DO}\\\SF*{DO*}}{\}}
    (\orGOO{%
      \VAR{var}\\
      (\VAR{var} \Op{ \VAR{start} \Op{\VAR{step}}})}{\}^{\!\!*}})
    (\VAR{stop} \OPn{\VAR{result}})
    \OPn{(\kwd{declare} \OPn{\VAR{decl}})} 
    \xorGOO{\VAR{tag}\\\VAR{form}}{\}^{\!\!*}})}
  Evaluate \SF{TAGBODY}-like body with \VAR{var}s successively bound according
  to the values of the corresponding \VAR{start} and \VAR{step}
  forms. \VAR{var}s are bound in parallel/sequentially, resp.
  Stop iteration when \VAR{stop} is \T. Return \retval{value of
    last \VAR{result}}.

  \IT{(\SF*{DOTIMES} (\VAR{var} \VAR{integer} \Op{\VAR{result}})
    \OPn{(\kwd{declare} \OPn{\VAR{decl}})} \Goos{\VAR{tag}\XOR\VAR{form}})}
  Evaluate \SF{TAGBODY}-like body with \VAR{var} successively bound
  to integers from 0 to $\mbox{\VAR{integer}} - 1$. Upon evaluation of
  \retval{\VAR{result}}, \VAR{var} is \NIL.

  \IT{(\SF*{DOLIST}(\VAR{var} \VAR{list} \Op{\VAR{result}})
    \OPn{(\kwd{declare} \OPn{\VAR{decl}})} \Goos{\VAR{tag}\XOR\VAR{form}})}
  Evaluate \SF{TAGBODY}-like body with \VAR{var} successively bound
  to the elements of \VAR{list}. Upon evaluation of
  \retval{\VAR{result}}, \VAR{var} is \NIL.


\end{LIST}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loop Facility}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}%
  \label{loop-overview}%
  \begin{center}%
    \begin{sideways}%
      (%  
      \arraycolsep0pt
      \(
      \text{\kwd{loop}}
      \left[
        \text{\LKWD{named} \VAR{n}}
        \right]
      \left\{
      \begin{array}{l}
        \text{\LKWD{with} \VAR{var} [\VAR{type}] \LKWD{=} \VAR{foo }} 
        \{\text{\LKWD{and} \VAR{var-n} [\VAR{type}] \LKWD{=} \VAR{bar}\}}^{*} \\
        \left.\!
        \begin{array}{l}
          \text{\LKWD{for}}  \\
          \text{\LKWD{as}} 
        \end{array}\right\}
        \boxed{
          \text{\VAR{var} [\VAR{type}]}
          \left\{
          \begin{array}{l}
            \left.\!
            \begin{array}{l}
              \left[
                \left\{
                \begin{array}{l}
                  \text{\LKWD{upfrom}}\\
                  \text{\LKWD{from}}
                \end{array}
                \right\}
                \text{\VAR{start}\DF{0}}
                \right]
              \left[
                \left\{
                \begin{array}{l}
                  \text{\LKWD{upto}}\\
                  \text{\LKWD{to}}\\
                  \text{\LKWD{below}}
                \end{array}
                \right\}
                \text{\VAR{form}}
                \right]\\
              \text{\LKWD{from} \VAR{start}}
              \left\{
              \begin{array}{l}
                \text{\LKWD{downto}}\\
                \text{\LKWD{above}}
              \end{array}
              \right\}              
              \text{\VAR{form }}\\
              \text{\LKWD{downfrom} \VAR{start}}
              \left[
                \left\{
                \begin{array}{l}
                  \text{\LKWD{downto}}\\
                  \text{\LKWD{to}}\\
                  \text{\LKWD{above}}
                \end{array}
                \right\}            
                \text{\VAR{form}}
                \right]
            \end{array}
            \right\}
            \left[   
              \text{\LKWD{by} \VAR{step}\DF{1}}
              \right]\\
            \left.\!
            \begin{array}{l}
              \text{\LKWD{in}} \\
              \text{\LKWD{on}}
            \end{array}
            \right\}
            \text{\VAR{list}} 
            \left[
              \text{\LKWD{by} \VAR{form}\DF{\kwd{\#'cdr}}}
              \right]\\
            \text{\LKWD{=} \VAR{foo }} 
            \left[
              \text{\LKWD{then} \VAR{bar}}
              \right] \\
            \text{\LKWD{across} \VAR{vector}}\\
            \text{\LKWD{being}}
            \left\{
            \begin{array}{l}
              \text{\LKWD{the}}\\          
              \text{\LKWD{each}}
            \end{array}
            \right\}%
            \left\{
            \begin{array}{{l}}
              \left.\!
              \begin{array}{l}
                \left.\!
                \begin{array}{l}
                  \text{\LKWD{hash-key}}\\
                  \text{\LKWD{hash-keys}}
                \end{array}
                \right\}%
                \left\{
                \begin{array}{l}
                  \text{\LKWD{of}}\\
                  \text{\LKWD{in}}
                \end{array}
                \right\}
                \text{\VAR{hash }} 
                \left[
                  \text{\LKWD{using} (\LKWD{hash-value} \VAR{v})}
                  \right]\\
                \left.\!
                \begin{array}{l}
                  \text{\LKWD{hash-value}}\\
                  \text{\LKWD{hash-values}}
                \end{array}
                \right\}%
                \left\{
                \begin{array}{l}
                  \text{\LKWD{of}}\\
                  \text{\LKWD{in}}
                \end{array}
                \right\}
                \text{\VAR{hash }}
                \left[
                  \text{\LKWD{using} (\LKWD{hash-key} \VAR{k})}
                  \right.\\
              \end{array}
              \right.\\
              \left.\!
              \begin{array}{l}
                \text{\LKWD{symbol\Op{s}}}\\
                \text{\LKWD{present-symbol\Op{s}}}\\
                \text{\LKWD{external-symbol\Op{s}}}
              \end{array}
              \right\}%
              \left[
                \left\{
                \begin{array}{l}
                  \text{\LKWD{of}}\\
                  \text{\LKWD{in}}
                \end{array}
                \right\} \text{\VAR{package}\DF{\V{*package*}}}
                \right]
            \end{array}
            \right.
          \end{array}
          \right\}_{\displaystyle{\mathbb{F}_0}}
                }%boxed
                \left\{
                \text{\LKWD{and} }\boxed{\mathbb{F}_i}
                \right\}^{\!*}\\
                \left.\!%
                \begin{array}{l}
                  \text{\LKWD{initially}} \\
                  \text{\LKWD{finally}} 
                \end{array} 
                \right\} 
                \text{\VAR{form}}^{+} \\
                
      \end{array}
      \right\}^{\!\!\displaystyle{*}}
      %Bottleneck
      \left\{
      \begin{array}{l}
        \text{\LKWD{repeat} \VAR{num}}\\
        \left.\!
        \begin{array}{l}
          \text{\LKWD{while}}\\
          \text{\LKWD{until}}\\
          \text{\LKWD{always}}\\
          \text{\LKWD{never}}\\
          \text{\LKWD{thereis}}
        \end{array}
        \right\} 
        \text{\VAR{test}}\\
        \boxed{
          \left.\!
          \begin{array}{l}
            \left.\!
            \begin{array}{l}
              \text{\LKWD{do}}\\
              \text{\LKWD{doing}}
            \end{array}
            \right\}
            \text{\VAR{form}}^{+}\\
            \text{\LKWD{return}}
            \left\{
            \begin{array}{l}
              \text{\VAR{form}}\\
              \text{\LKWD{it}}
            \end{array}
            \right.\\
            \left.\!
            \begin{array}{l}
              \text{\LKWD{collect\Op{ing}}}\\
              \text{\LKWD{append\Op{ing}}}\\
              \text{\LKWD{nconc\Op{ing}}}
            \end{array}
            \right\}
            \left\{
            \begin{array}{l}
              \text{\VAR{form}}\\
              \text{\LKWD{it}}
            \end{array}
            \right\} [\text{\LKWD{into }\VAR{var}}]\\
            \left.\!
            \begin{array}{l}
              \text{\LKWD{count\Op{ing}}}\\
              \text{\LKWD{sum\Op{ming}}}\\
              \text{\LKWD{maximize}}\\
              \text{\LKWD{maximizing}}\\
              \text{\LKWD{minimize}}\\
              \text{\LKWD{minimizing}}
            \end{array}
            \right\}
            \left\{
            \begin{array}{l}
              \text{\VAR{form}}\\
              \text{\LKWD{it}}
            \end{array}
            \right\} 
                [\text{\LKWD{into }\VAR{n}}]
                [\text{\VAR{type}}]\\
                \left.\!
                \begin{array}{l}
                  \text{\LKWD{if}}\\
                  \text{\LKWD{when}}\\
                  \text{\LKWD{unless}}
                \end{array}
                \right\}%
                \text{\VAR{test }}
                \boxed{\mathbb{S}_i}\{\text{\LKWD{and}}%
                \boxed{\mathbb{S}_j}\}^{*}[\text{\LKWD{else}}%
                  \boxed{\mathbb{S}_k}\{\text{\LKWD{and}}%
                  \boxed{\mathbb{S}_l}\}^{*}][\text{\LKWD{end}}]
          \end{array}
          \right._{\!\!\!\!\displaystyle{\mathbb{S}_0}}
        }%boxed
        \\
        \left.\!
        \begin{array}{l}
          \text{\LKWD{initially}} \\
          \text{\LKWD{finally}} 
        \end{array} 
        \right\}
        \text{\VAR{form}}^{+}
      \end{array}
      \right\}^{\displaystyle{\!\!*}}
      \)%
      \!)%
    \end{sideways}%
  \end{center}\vspace{-1em}
  \caption{Loop Facility, Overview.}%
\end{figure}


\begin{LIST}{1cm}

  \IT{(\SF*{LOOP} \OPn{\VAR{form}})} 
  Simple Loop. If \VAR{form}s do
  not include any keywords of the Loop Facility, evaluate them forever. 

  \IT{(\SF*{LOOP} \OPn{\VAR{form}})} 
  Loop Facility. If there are loop facility keywords in \VAR{form}s
  see below and p.\ \pageref{loop-overview}.

  \begin{LIST}{.5cm}
    
    \IT{\LKWD*{named} \VAR{n}}
    Gives implicit \kwd{block} of loop a name.

    \IT{\LKWD*{with} \VAR{var} \LKWD*{=} \VAR{foo} \Op{\VAR{type}} \Goo{\LKWD*{and}
        \VAR{var-n} \Op{\VAR{type}} \LKWD*{=} \VAR{bar}}}
    Initialize local variables in parallel.

    \IT{\Goo{\LKWD*{initially}\XOR\LKWD*{finally}} \RP{\VAR{form}}}
    Evaluate \VAR{form} before begin, or after end, resp., of iterations.

    \IT{\Goo{\LKWD*{for}\XOR\LKWD*{as}} \VAR{var} \VAR{type}}
    Begin of iteration control clause.

    \begin{LIST}{.25cm}

      \IT{\Goo{\LKWD*{upfrom}\XOR\LKWD*{from}\XOR\LKWD*{downfrom}} \VAR{start}}
      Start stepping with \VAR{form}

      \IT{\Goo{\LKWD*{upto}\XOR\LKWD*{downto}\XOR\LKWD*{to}\XOR\LKWD*{below}\XOR\LKWD*{above}} \VAR{form}}
      Specify \VAR{form} as the end value for stepping.

      \IT{\Goo{\LKWD*{in}\XOR\LKWD*{on}} \VAR{list}}
      Bind \VAR{var} to successive elements/tails, resp., of \VAR{list}.

      \IT{\LKWD*{by} \VAR{step}\DF{1}}
      Specify the (positive) decrement or increment.

      \IT{\LKWD*{=} \VAR{foo} \Op{\LKWD*{then} \VAR{bar}\DF{\VAR{foo}}}}
      Bind \VAR{var} in the first iteration to  \VAR{foo} and later to \VAR{bar}.

      \IT{\LKWD*{across} \VAR{vector}}
      Bind \VAR{var} to successive elements of \VAR{vector}.

      \IT{\LKWD*{being}\Goo{\LKWD*{the}\XOR\LKWD*{each}}}
      Iterate over a hash table or a package.

      \begin{LIST}{.5cm}

        \IT{\Goo{\LKWD*{hash-key}\XOR\LKWD*{hash-keys}}\Goo{\LKWD*{of}\XOR\LKWD*{in}} \VAR{hash-table}
          \Op{\LKWD*{using} (\LKWD*{hash-value} \VAR{value})}}
        Bind \VAR{var} successively to the keys of \VAR{hash-table}; bind corresponding values to \VAR{value}.

        \IT{\Goo{\LKWD*{hash-value}\XOR\LKWD*{hash-values}}\Goo{\LKWD*{of}\XOR\LKWD*{in}} \VAR{hash-table}
          \Op{\LKWD*{using} (\LKWD*{hash-key} \VAR{key})}}
        Bind \VAR{var} successively to the values of \VAR{hash-table}; bind corresponding keys to \VAR{key}.

        \IT{\Goo{\LKWD*{symbol}\XOR\LKWD*{symbols}\XOR\LKWD*{present-symbol}\XOR\LKWD*{present-symbols}\XOR\LKWD*{external-symbol}\XOR\LKWD*{external-symbols}}\Op{\Goo{\LKWD*{of}\XOR\LKWD*{in}}
            \VAR{package}}} 
        Bind \VAR{var} successively to the symbols, or the present symbols, or the external symbols, resp., of \VAR{package}.

      \end{LIST}
    \end{LIST}
    
    \IT{\LKWD*{and} \VAR{var}}
    Begin of another iteration control clause with variables initialized and stepped in parallel.

    \IT{\Goo{\LKWD*{do}\XOR\LKWD*{doing}} \RP{\VAR{form}}}
    Evaluate \VAR{form}s in every iteration.
    
    \IT{\LKWD*{return} \Goo{\VAR{form}\XOR\LKWD*{it}}}
    Return immediately with return value \VAR{form}.
    
    \IT{\Goo{\LKWD*{collect}\XOR\LKWD*{collecting}}\Goo{\VAR{form}\XOR\LKWD*{it}}\Op{\LKWD*{into} \VAR{list}}}
    Collect values of \VAR{form} into \VAR{list}. If no \VAR{list} is given, collect into an anonymous list
    which is returned after termination.

    \IT{\Goo{\LKWD*{append}\XOR\LKWD*{appending}\XOR\LKWD*{nconc}\XOR\LKWD*{nconcing}}\Goo{\VAR{form}\XOR\LKWD*{it}}\Op{\LKWD*{into} \VAR{list}}}
    Concatenate values of \VAR{form}, which must be lists, into \VAR{list} by the means of \FU{append} 
    or \FU{nconc}, resp.  If no \VAR{list} is given, collect into an anonymous list
    which is returned after termination.

    \IT{\Goo{\LKWD*{count}\XOR\LKWD*{counting}}\Goo{\VAR{form}\XOR\LKWD*{it}}\Op{\LKWD*{into} \VAR{n}}}
    Count the number of times \VAR{form} returns \T.
    
    \IT{\Goo{\LKWD*{sum}\XOR\LKWD*{summing}}\Goo{\VAR{form}\XOR\LKWD*{it}}\Op{\LKWD*{into} \VAR{sum}}}
    Calculate the sum of the values of \VAR{form}.
    
    \IT{\Goo{\LKWD*{maximize}\XOR\LKWD*{maximizing}\XOR
        \LKWD*{minimize}\XOR
        \LKWD*{minimizing}}\Goo{\VAR{form}\XOR\LKWD*{it}}\Op{\LKWD*{into}
        \VAR{max-min}}} 
    Determine the maximum or minimum, resp., of all values of
    \VAR{form}. 
    
    \IT{\Goo{\LKWD*{if}\XOR\LKWD*{when}\XOR\LKWD*{unless}}\VAR{ test}
      \VAR{form-i} \Goos{\LKWD*{and} 
        \VAR{form-j}}\Op{\LKWD*{else} \VAR{form-k} \Goos{\LKWD*{and} 
          \VAR{form-l}}} \Op{\LKWD*{end}}} 
    If \VAR{test} returns \T, \T, or \NIL, resp., evaluate
    \VAR{form-i} and \VAR{form-j}s; otherwise, evaluate \VAR{form-k}
    and \VAR{form-l}s. Inside \VAR{form-i} and \VAR{form-k}, the value
    of \VAR{test} is accessible by \LKWD*{it}. 
    
    \IT{\LKWD*{repeat} \VAR{num}}
    Terminate \SF{loop} after \VAR{num} times; \VAR{num} is evaluated once.

    \IT{\Goo{\LKWD*{while}\XOR\LKWD*{until}} \VAR{test}}
    Continue iteriation until \VAR{test} returns \NIL, or \T, resp.

    \IT{\Goo{\LKWD*{always}\XOR\LKWD{never}} \VAR{test}}
    Terminate \SF{loop} returning \NIL\ and skipping any \LKWD*{finally} parts as soon as \VAR{test} is \NIL, or \T, resp. Otherwise continue \SF{loop} with its default return value set to \T.

    \IT{\LKWD*{thereis} \VAR{test}}
    Terminate \SF{loop} when \VAR{test} is \T\ and return value of \VAR{form}, skipping any \LKWD*{finally} parts. Otherwise continue \SF{loop} with its default return value set to \T.

    \IT{\LKWD*{loop-finish}}
    Terminate \SF{loop} immediately; skip any \LKWD*{finally} parts
  \end{LIST}
\end{LIST}


